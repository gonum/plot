// Copyright Â©2015 The gonum Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package vg_test

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"testing"

	"github.com/gonum/plot"
	"github.com/gonum/plot/plotter"
	"github.com/gonum/plot/vg"
	"github.com/gonum/plot/vg/draw"
	"github.com/gonum/plot/vg/vgeps"
	"github.com/gonum/plot/vg/vgimg"
	"github.com/gonum/plot/vg/vgpdf"
	"github.com/gonum/plot/vg/vgsvg"
)

var generateTestData = flag.Bool("regen", false, "Uses the current state to regenerate the test data.")

// TestLineWidth tests output against test images generated by
// running tests with -tag good.
func TestLineWidth(t *testing.T) {
	formats := []string{
		// TODO: Add logic to cope with run to run eps differences.
		"pdf",
		"svg",
		"png",
		"tiff",
		"jpg",
	}

	const (
		width  = 100
		height = 100
	)

	for _, w := range []vg.Length{-1, 0, 1} {
		for _, typ := range formats {
			p, err := lines(w)
			if err != nil {
				log.Fatalf("failed to create plot for %v:%s: %v", w, typ, err)
			}

			var c interface {
				vg.Canvas
				Size() (w, h vg.Length)
				io.WriterTo
			}

			name := filepath.Join(".", "testdata", fmt.Sprintf("width_%v.%s", w, typ))
			switch typ {
			case "eps":
				c = vgeps.NewTitle(width, height, name)

			case "jpg":
				c = vgimg.JpegCanvas{Canvas: vgimg.New(width, height)}

			case "pdf":
				c = vgpdf.New(width, height)

			case "png":
				c = vgimg.PngCanvas{Canvas: vgimg.New(width, height)}

			case "svg":
				c = vgsvg.New(width, height)

			case "tiff":
				c = vgimg.TiffCanvas{Canvas: vgimg.New(width, height)}

			default:
				panic("bad typ string: " + typ)
			}

			p.Draw(draw.New(c))

			var buf bytes.Buffer
			if _, err = c.WriteTo(&buf); err != nil {
				t.Fatalf("failed to write plot for %v:%s: %v", w, typ, err)
			}

			// Recreate Golden images.
			if *generateTestData {
				err = p.Save(width, height, name)
				if err != nil {
					log.Fatalf("failed to save %q: %v", name, err)
				}
			}

			f, err := os.Open(name)
			if err != nil {
				t.Fatalf("failed to open test image: %v", err)
			}
			want, err := ioutil.ReadAll(f)
			if err != nil {
				t.Fatalf("failed to read test image: %v", err)
			}
			f.Close()
			if !bytes.Equal(buf.Bytes(), want) {
				t.Errorf("image mismatch for %v:%s", w, typ)
			}
		}
	}
}

func lines(w vg.Length) (*plot.Plot, error) {
	p := plot.New()
	pts := plotter.XYs{{0, 0}, {0, 1}, {1, 0}, {1, 1}}
	line, err := plotter.NewLine(pts)
	line.Width = w
	if err != nil {
		return nil, err
	}
	p.Add(line)

	return p, nil
}
